---
title: "`r params$report_title`"
output: 
  html_document:
    toc: true
    toc_float: false
    number_sections: true
    theme: cosmo
    highlight: tango
    code_folding: none
params:
  report_title: "BCB-SR RNA-seq Report"  # default fallback
  params_file: 
pandoc_args: 
  - "+RTS" 
  - "-K16000m"
  - "-RTS"
date: "`r format(Sys.time(), '%m/%d/%y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE, fig.align="center")
library(ggplot2)
library(gridExtra)
library(DT)
library(limma)
library(edgeR)
library(qs)
library(kableExtra)
library(yaml)
source("R/helper-funcs.R")
library(downloadthis)
select <- dplyr::select
```

```{r params}
parse_params <- function(filepath) {
  lines <- readLines(filepath)
  param_list <- list()
  
  for (line in lines) {
    line <- trimws(line)
    
    # Skip empty lines and comments
    if (line == "" || startsWith(line, "#")) {
      next
    }
    
    if (grepl("^--", line)) {
      space_pos <- regexpr("\\s", line)
      
      if (space_pos > 0) {
        key <- gsub("^--", "", substr(line, 1, space_pos - 1))
        
        # NORMALIZE HYPHENS TO UNDERSCORES for consistency
        key <- gsub("-", "_", key)
        
        value <- trimws(substr(line, space_pos + 1, nchar(line)))
        
        # Remove surrounding quotes
        if ((startsWith(value, '"') && endsWith(value, '"')) ||
            (startsWith(value, "'") && endsWith(value, "'"))) {
          value <- substr(value, 2, nchar(value) - 1)
        }
        
        # Convert logical strings
        if (tolower(value) == "true") {
          value <- TRUE
        } else if (tolower(value) == "false") {
          value <- FALSE
        }
        
        param_list[[key]] <- value
      }
    }
  }
  
  return(param_list)
}

# Determine which params file to use
if (exists("params") && !is.null(params$params_file) && file.exists(params$params_file)) {
  # Production mode: read from passed-in params
  report_params <- parse_params(params$params_file)
  
  # CRITICAL: Merge with directly-passed params, giving them priority
  for (param_name in names(params)) {
    if (param_name != "params_file") {
      report_params[[param_name]] <- params[[param_name]]
    }
  }
  
} else {
  # Interactive/testing mode - UPDATE PATH HERE
  report_params <- parse_params("/blue/cancercenter-dept/PROJECTS/CLANTON/GE8593/resources/rnareport_params.txt")
}
```

```{r analysis}
# Source the function definition
source("R/analysis.R")

# Run the analysis and extract results
analysis_results <- run_rnaseq_analysis(report_params)

# Unpack results into global environment for backwards compatibility
list2env(analysis_results, envir = .GlobalEnv)
```

# Project Summary

**PI**: `r report_params$PI`

**Institution**: `r report_params$Institution`

**Department**: `r report_params$Department`

**Study Contact**: `r report_params$Study_Contact`

**Project Title**: `r report_params$Project_Title`

**Study Summary**: `r report_params$Study_Summary`

**Sample type(s)**: `r report_params$Sample_Types`

**Organism**: `r report_params$Organism`

**Analysis goal(s)**: `r report_params$Analysis_Goals`

**Report-prepared-by**:  
  - `r report_params$Report_Prepared_By`
  
**Report-reviewed-by**:  
  - `r report_params$Report_Reviewed_By`

# Data Downloads

## Download Raw Sequencing Data  

Below is a link to download the raw sequencing files. These files are very large (>150GB); download only when needed. Note that you **must be logged into your UF dropbox account** for this link to work.

```{r download raw data, echo=FALSE, results="asis"}
url <- report_params$raw_seq_URL

if (url == "") {
  cat("<p><em>This file was not included in this report.</em></p>")
} else {
  cat(sprintf('<a href="%s" class="btn btn-primary" role="button" download>Download Raw Sequence Files</a>', url))
}
```

## Download Sequencing Data Quality Control Summary

FastQC provides quality metrics for individual sequencing samples, including read quality, GC content, and adapter contamination. The MultiQC report summarizes these results across all samples. The multiQC report is of raw sequence data. These data were quality filtered and trimmed prior to analysis. For guidance on interpreting the results, see [FastQC documentation](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

```{r download multiqc, echo=FALSE, results="asis"}
url <- report_params$multiqc_url

if (url == "") {
  cat("<p><em>This file was not included in this report.</em></p>")
} else {
  cat(sprintf('<a href="%s" class="btn btn-primary" role="button" download>Download MultiQC Report</a>', url))
}
```

```{r setup_method_text, echo=FALSE}
# Build filtering method text based on parameters
if (exists("report_params") && !is.null(report_params$filter_method)) {
  if (report_params$filter_method == "NOISeq") {
    filter_text <- sprintf(
      "Raw RNA-seq counts were filtered using NOISeq's filtered.data function (method=%s, CPM threshold=%s, CV cutoff=%s%%) to remove lowly expressed genes. Genes were retained if the sum of CPM values across samples in at least one condition exceeded CPM × number of samples, and had a coefficient of variation ≤%s%% within conditions.",
      report_params$noiseq_method,
      report_params$cpm,
      report_params$cv_cutoff,
      report_params$cv_cutoff
    )
  } else {
    # Default to edgeR
    filter_text <- sprintf(
      "Raw RNA-seq counts were filtered using edgeR's filterByExpr function (min.count=%s, min.prop=%s) to remove lowly expressed genes. Genes were retained if they achieved at least %s counts in at least %.0f%% of samples within at least one group.",
      report_params$filter_min_count,
      report_params$filter_min_prop,
      report_params$filter_min_count,
      as.numeric(report_params$filter_min_prop) * 100
    )
  }
} else {
  # Fallback if parameters don't exist
  filter_text <- "Raw RNA-seq counts were filtered to remove lowly expressed genes."
}

# Set method description based on actual DE tool used
if (exists("de_method") && !is.null(de_method)) {
  
  # Check if paired design was used
  paired_text <- ""
  if (!is.null(report_params$paired_design) && report_params$paired_design == TRUE && 
      !is.null(report_params$batch_var)) {
    if (de_method == "limma_voom") {
      paired_text <- sprintf(" To account for the paired study design, the duplicateCorrelation function was used with '%s' as a blocking factor, modeling within-subject correlation as a random effect.", 
                            report_params$batch_var)
    } else {
      paired_text <- sprintf(" To account for the paired study design, '%s' was included in the design matrix as a fixed effect blocking factor.", 
                            report_params$batch_var)
    }
  }
  
  method_text <- switch(de_method,
    "deseq2" = paste0(
      "Differential expression analysis was performed using DESeq2 (Love et al. 2014). ",
      filter_text,
      " DESeq2's negative binomial generalized linear model was used to model count data, estimate gene-wise dispersion parameters, and perform differential expression testing.",
      paired_text,
      " Log-fold changes were shrunk using apeglm to provide more accurate effect size estimates by reducing noise in low-count genes."
    ),
    "edger_GLM" = paste0(
      "Differential expression analysis was performed using edgeR GLM quasi-likelihood pipeline (Robinson et al. 2010, Chen et al. 2016). ",
      filter_text,
      " TMM normalization was applied to calculate normalization factors, followed by estimation of gene-wise negative binomial dispersions using the Cox-Reid profile-adjusted likelihood method.",
      paired_text,
      " Differential expression was assessed using quasi-likelihood F-tests, which provide more robust error rate control than likelihood ratio tests."
    ),
    "limma_voom" = paste0(
      "Differential expression analysis was performed using the limma-voom pipeline (Law et al. 2014, Ritchie et al. 2015). ",
      filter_text,
      " TMM normalization factors were calculated to account for differences in library sizes and RNA composition between samples. The voom function transformed count data to log2-counts-per-million (logCPM) and estimated the mean-variance relationship to calculate precision weights for each observation. These weights account for the mean-variance trend in RNA-seq data (heteroscedasticity).",
      paired_text,
      " A linear model was fitted to the weighted transformed data, and contrasts were computed for pairwise comparisons. Moderated t-statistics were calculated using empirical Bayes methods, which borrow information across genes to shrink gene-wise variance estimates toward a common value, improving statistical power especially for small sample sizes."
    ),
    paste0(
      "Differential expression analysis was performed using standard methods for RNA-seq data. ",
      filter_text
    )
  )
} else {
  method_text <- paste0(
    "Differential expression analysis was performed using standard methods for RNA-seq data. ",
    filter_text
  )
}
```

## Download Raw and Filtered Counts Data

Description of Data Sheets:

1. **Raw**: Raw gene count matrix before filtering or normalization.
2. **Filtered**: Gene expression counts filtered to remove lowly-expressed and non-variable genes using the `r report_params$filter_method` method. **This dataset was used as input for DE analysis.**
3. **CPM / CPM.batchcorrected**: Counts per million (CPM) normalized expression values, with gene symbols. If batch correction was applied (see methods), this sheet contains values back-transformed from the batch-corrected log-CPM matrix.
4. **LCPM / LCPM.batchcorrected**: Log-transformed CPM values, either uncorrected or batch corrected (if correction was requested), useful for visualization.
5. **Sample_Metadata**: Sample information including treatment, group, and library sizes.

The Excel file containing these datasets can be downloaded using the link provided below.

```{r download count data}
# Load necessary libraries
library(openxlsx)
library(dplyr)

# Extract count matrices from DGELists and add gene symbols
extract_dge_data <- function(dge) {
  df <- as.data.frame(dge$counts)
  df$ENSEMBL <- rownames(dge$counts)
  df <- left_join(df, dge$genes, by = "ENSEMBL")  # Add gene symbols
  df <- df %>% select(SYMBOL, everything())  # Move gene names to first column
  return(df)
}

dge_filtered_df <- extract_dge_data(dge_list_filt)
dge_raw_df <- extract_dge_data(dge_list_raw)

# Convert matrices to dataframes and add gene symbols
convert_matrix <- function(matrix, genes_df) {
  df <- as.data.frame(matrix)
  df$ENSEMBL <- rownames(matrix)
  df <- left_join(df, genes_df, by = "ENSEMBL")  # Add gene symbols
  df <- df %>% select(SYMBOL, everything())  # Move gene names to first column
  return(df)
}

# Determine whether to use batch-corrected log-CPM matrix
use_batch_corrected <- !is.null(report_params$batch_var) &&
                       report_params$batch_var == "Batch" &&
                       !is.null(dge_list_filt$E_corrected)

if (use_batch_corrected) {
  message("Using batch-corrected matrix for both CPM and LCPM output.")
  lcpm_matrix <- dge_list_filt$E_corrected
  cpm_matrix <- 2^lcpm_matrix  # Back-transform

  cpm_df <- convert_matrix(cpm_matrix, dge_list_filt$genes)
  lcpm_df <- convert_matrix(lcpm_matrix, dge_list_filt$genes)

  cpm_name <- "CPM.batchcorrected"
  lcpm_name <- "LCPM.batchcorrected"
} else {
  lcpm_matrix <- cpm(dge_list_filt, log = TRUE)
  cpm_matrix <- cpm(dge_list_filt)

  cpm_df <- convert_matrix(cpm_matrix, dge_list_filt$genes)
  lcpm_df <- convert_matrix(lcpm_matrix, dge_list_filt$genes)

  cpm_name <- "CPM"
  lcpm_name <- "LCPM"
}

# Extract sample metadata
sample_metadata <- dge_list_filt$samples

# Create a list of dataframes to be written to an Excel file
df_list <- list(
  "Raw" = dge_raw_df,
  "Filtered" = dge_filtered_df,
  cpm_df,
  lcpm_df,
  "Sample_Metadata" = sample_metadata
)

# Rename CPM and LCPM elements after the list is created
names(df_list)[3:4] <- c(cpm_name, lcpm_name)

if (!is.null(report_params$batch_var) && report_params$batch_var == "Batch" && !is.null(dge_list_filt$E_corrected)) {
  cat("The CPM and LCPM matrices have been batch-corrected using limma::removeBatchEffect. These corrected matrices are labeled CPM.batchcorrected and LCPM.batchcorrected in the downloadable Excel file.")
} else {
  cat("Note:No batch correction was applied. CPM and LCPM matrices are based on the standard log-transformed CPM from filtered counts.")
}

# Generate a download button
df_list %>% downloadthis::download_this(
  output_name = "RNAseq_Data_Analysis",
  output_extension = ".xlsx",
  button_label = "Download RNA-seq Data File",
  button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save"
)
```

# Data Visualizations

## PCA (multivariate analaysis)</span>

Principal component analysis of gene expression data were calculated in R v4.3.3. Two-dimensional PCA score plots reveal possible separation in gene expression profiles and can help to identify quality control issues and batch effects. Ellipses are calculated using the R package car (Fox J. and Weisberg S. 2019) and ~1 Std dev.

### PCA of all samples

If batch correction was applied using limma::removeBatchEffect(), the plots below compare PCA of the filtered expression matrix before and after correction. This allows visualization of how batch effects were reduced while preserving biological signal.

```{r pca all, fig.width=12, fig.height=4}
# Simplified - just show before/after filtering or batch correction
if (!is.null(report_params$batch_var) && report_params$batch_var == "Batch" && !is.null(dge_list_filt$E_corrected)) {
  # Show uncorrected vs corrected
  dge_uncorrected <- edgeR::DGEList(
    counts = dge_list_filt$counts,
    samples = dge_list_filt$samples,
    genes = dge_list_filt$genes
  )
  
  dge_corrected <- edgeR::DGEList(
    counts = 2^dge_list_filt$E_corrected,
    samples = dge_list_filt$samples,
    genes = dge_list_filt$genes
  )
  
  dge_list <- list(dge_uncorrected, dge_corrected)
  annotation_labels <- c("Filtered Genes (logCPM, uncorrected)", 
                         "Filtered Genes (logCPM, batch corrected)")
} else {
  # Show raw vs filtered
  dge_list <- list(dge_list_raw, dge_list_filt)
  annotation_labels <- c("All Genes (logCPM)", 
                         "Filtered Genes (logCPM)")
}

plot_pca_combined(dge_list, grp_var = report_params$group_var, annotation_labels = annotation_labels)
```

### PCA per-contrast

```{r contrast pcas, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
# Generate list of PCA plots (ggplot objects)
pca_results <- lapply(names(efit_results_dfs), function(contrast_name) {
  plot_one_pca_by_contrast(
    dge_list = dge_list_filt,
    contrast_name = gsub("_results_df", "", contrast_name),
    group_var = report_params$group_var
  )
})

# Display PCA plots
tagList(pca_results)
```

## Global comparison of transcriptional profile similarity between groups

### Spearman correlation

Pairwise sample-to-sample correlation coefficients of log CPM normalized filtered counts were calculated using Spearman’s rank correlation in R v4.3.3 and visualized using pheatmap 1.0 (Kolde 2019).

```{r corr,fig.width=12, fig.height=12}
library(pheatmap)
library(tibble)
library(RColorBrewer)
library(grid)

# Filter samples
if (!is.null(report_params$filter_samples) && report_params$filter_samples != ""){
  selected_samples <- sample.keys %>%
    filter(!SampleName %in% report_params$filter_samples) %>%
    pull(SampleName)
} else {
  selected_samples <- sample.keys %>% pull(SampleName)
}

# Subset lcpm
lcpm_filtered <- lcpm_matrix[, colnames(lcpm_matrix) %in% selected_samples]

# Spearman correlation
cor_matrix <- cor(lcpm_filtered, method = "spearman")

# Annotations
annotation_col <- sample.keys %>%
  filter(SampleName %in% colnames(cor_matrix)) %>%
  select(SampleName, all_of(report_params$group_var)) %>%
  column_to_rownames("SampleName")

# Dynamic color palette
group_levels <- sort(unique(annotation_col[[report_params$group_var]]))
n_groups <- length(group_levels)

if (n_groups <= 8) {
  color_palette <- brewer.pal(n_groups, "Set2")
} else {
  color_palette <- colorRampPalette(brewer.pal(8, "Set2"))(n_groups)
}
ann_colors <- setNames(color_palette, group_levels)

# Correlation color scale
red_palette <- colorRampPalette(c("blue", "white", "red"))(100)
min_val <- min(cor_matrix)
max_val <- max(cor_matrix)
breaks_seq <- seq(min_val^2, max_val^2, length.out = 101)^(1/2)

# Automatically adjust plot size
n_samples <- ncol(cor_matrix)
display_numbers_flag <- n_samples <= 40
fig_height <- max(6, n_samples * 0.25)
fig_width <- max(6, n_samples * 0.25)

# Draw with layout control
p <- pheatmap(
  cor_matrix,
  color = red_palette,
  breaks = breaks_seq,
  annotation_col = annotation_col,
  annotation_row = annotation_col,
  annotation_colors = setNames(list(ann_colors), report_params$group_var),
  clustering_method = "complete",
  main = paste("Spearman's Correlation Plot for Normalized Read Counts (lcpm) filtered by", report_params$group_var),
  display_numbers = display_numbers_flag,
  number_format = "%.3f",
  fontsize = 10,
  fontsize_number = 6,
  number_color = "black",
  fontsize_row = 6,
  fontsize_col = 6,
  silent = TRUE  # return the object instead of drawing immediately
)

# Force proper rendering in Rmd
grid.newpage()
grid.draw(p$gtable)

```

### Heatmap of top 1000 CV genes

Scaled gene expression values of the top 1000 variable genes (sd/mean) were visualized using pheatmap 1.0 (Kolde 2019) with sample and gene clustered by complete hierarchical clustering.

```{r,fig.width=12,fig.height=6}
# Step 3: Identify the top 1000 most variable genes by CV
# Step: Identify top 1000 most variable genes by CV
cv_values <- apply(lcpm_filtered, 1, function(x) sd(x) / mean(x))
top_1000_genes <- names(sort(cv_values, decreasing = TRUE))[1:1000]
lcpm_top1000 <- lcpm_filtered[top_1000_genes, ]

# Step: Plot
pheatmap(
  lcpm_top1000,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  annotation_col = annotation_col,
  annotation_colors = setNames(list(ann_colors), report_params$group_var),
  clustering_method = "complete",
  scale = "row",
  show_rownames = FALSE,
  show_colnames = TRUE,
  main = "Top 1000 Most Variable Genes' (CV) Expression (Z-score) by Sample",
  fontsize = 10
)
```

## Mean-Variance Relationship: Before and After Variance Moderation

These **mean-variance trend** plots are provided to illustrate how the DE analysis ensure differential expression (DE) results are **not biased by expression-dependent variance**. The top plot shows how **variance changes with expression level** in the raw data. Typically, variance **decreases** as expression increases. This confirms that `voom()` correctly models **heteroscedasticity (unequal variance)** in RNA-seq data. The **Bottom plot** shows variance **after empirical Bayes shrinkage** using `eBayes()`. The trend should be **flat**, indicating variance is properly stabilized. 

## Mean-Variance Relationship: Before and After Variance Moderation

```{r SA plot side by side, eval=!is.null(voom_plot_path), fig.width=8, fig.height=4}
# Only show this section if limma-voom was used
library(gridExtra)
library(grid)
library(png)

# Load the PNG plot as a raster image
img <- rasterGrob(readPNG(voom_plot_path), interpolate = TRUE)

# Open a graphics device, plot `plotSA()`, then capture it
tmp <- tempfile(fileext = ".png")
invisible(png(tmp, width = 600, height = 600, res = 150))
par(mar=c(3, 5, 2, 2), cex.axis=0.7, cex.lab=0.7, cex.main=0.7)  
plotSA(efit_list[[1]], main = "Final model: Mean-Variance trend")
invisible(dev.off())

# Load the saved plot as a raster image
plot_sa_grob <- rasterGrob(readPNG(tmp), interpolate = TRUE)

# Arrange both images side by side
grid.arrange(img, plot_sa_grob, ncol = 2)
```

# Differential Expression Analysis

```{r methods_text, results='asis', echo=FALSE}
cat(method_text)
```

```{r,results='asis'}
# Print the number of contrasts tested
cat(paste0(length(names(efit_list)), " contrasts were tested:"))

# Create a table of contrasts
contrast_table <- data.frame("Contrast" = names(efit_list))
kable(contrast_table, format = "html", caption = "Table: Tested Contrasts")
```

## Summary of DE results per contrast

Down-regulated: adj. p value < 0.05 **AND** logFC > 0.58

Up-regulated: adj. p value < 0.05 **AND** logFC < -0.58

Not Significant: adj. p value > 0.05 **AND/OR** abs(logFC) > 0.58

```{r DE_summary_all, echo=FALSE, results='asis'}
tagList(
  lapply(seq_along(efit_list), function(i) {
    display_de_summary(efit_list[[i]],contrast=names(efit_list)[i])  # Directly return the datatable
  })
)
```

## Interactive Downloadable Differential Expression Results Tables

- Summary per contrast showing the number of differentially expressed genes and key statistics.
- **Tables can be filtered, sorted, and downloaded**  

```{r download tables}
# Convert efit_list to a named list of data frames with contrast column
efit_df_list <- lapply(seq_along(efit_list), function(i) {
  contrast_name <- gsub("^X| X", "", names(efit_list)[i])
  df <- download_de_result_table(efit_list[[i]])
  df$contrast <- contrast_name
  return(df)
})

names(efit_df_list) <- gsub("^X| X", "", names(efit_list))

# Download GO results as an Excel file
efit_df_list %>% downloadthis::download_this(
  output_name = paste0(report_params$Project_Title,"DE_results_all_contrasts"),
  output_extension = ".xlsx",
  button_label = "Download DE results for all contrasts",
button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save"
)
```

```{r view tables}
tagList(
  lapply(seq_along(efit_list), function(i) {
    contrast_name <- gsub("^X| X", "", names(efit_list)[i])
    display_de_result_table(efit_list[[i]], contrast_name = contrast_name)  # Directly return the datatable
  })
)
```

## Differential Expression Results Visualizations

### Volcano Plots

Visualization of **log-fold changes vs. statistical significance** for each contrast (plotly v4.1 (Sievert C 2020)) shows patterns of **significantly up/downregulated genes** ("significance" determined by adj. p value < 0.05 ***AND** abs(logFC) > 0.58).

```{r volcano_plots_all, echo=FALSE, results='asis', fig.width=9, fig.height=5}
# Generate all volcano plots and store in a list
volcano_plots <- lapply(seq_along(efit_results_dfs), function(i) {
  generate_volcano_plot(efit_results_dfs[[i]], paste0(gsub("efit_|_results_df","",names(efit_results_dfs)[i]), "\n")) %>%
    style(marker = list(size = 2))
})

# Render all plots
tagList(volcano_plots)
```

### Heatmaps

Heatmaps of the **top 50 DE genes** for each contrast show the scaled counts values for all samples in that contrast using heatmaply v1.5 (Galili et al. 2017). Hierarchical clustering of samples is based on expression patterns.

```{r heatmaps of top DE genes,fig.width=9, fig.height=9}
heatmap_list <- lapply(seq_along(efit_results_dfs), function(i) {
  generate_heatmap(
    efit_results_df = efit_results_dfs[[i]],  
    lcpm_matrix = lcpm_matrix,  
    dge_list_filt = dge_list_filt,  
    title = paste("Scaled Gene Expression (Z-scores of logCPM) of Top 50 DE Genes\n", gsub("efit_|_results_df","",names(efit_results_dfs)[i])),  
    num_genes = 50,  
    fontsize_row = 9
  )
})
tagList(heatmap_list)
```

# Pathway Enrichment Analysis

Pathway enrichment analysis was performed to identify functional enrichment of gene lists and to compare these significant results across contrasts.

If a contrast had fewer than five significant genes using the standard filtering (p adj < 0.05; abs(log2FC) > 0.58), relaxed filtering was applied to the DE results (adj.P < 0.1, No log2FC filtering) to create an input gene list for the enrichment analyses. If no genes passed standard or relaxed filtering criteria, the enrichment analysis was not performed for that contrast-direction (see warning messages).

```{r gene-list-and-messages, eval=TRUE}
# Generate dynamic gene lists and collect enrichment messages
enrichment_messages <- c()

for (i in seq_along(entrez_ids_list)) {
  contrast_name <- names(entrez_ids_list)[i] %>%
    gsub("top_DE_entrezIDs_?", "", .)
  
  up_entry <- entrez_ids_list[[i]]$up
  down_entry <- entrez_ids_list[[i]]$down
  
  # Check BOTH up and down messages
  if (!is.null(up_entry$message)) {
    enrichment_messages <- c(enrichment_messages, 
                            paste0(gsub("efit_|_results_df", "", contrast_name), 
                                   " (up): ", up_entry$message))
  }
  
  if (!is.null(down_entry$message)) {
    enrichment_messages <- c(enrichment_messages, 
                            paste0(gsub("efit_|_results_df", "", contrast_name), 
                                   " (down): ", down_entry$message))
  }
}
```

```{r enrichment-messages, results='asis', echo=FALSE}
if (length(enrichment_messages) > 0) {
  cat("### ⚠️ Notes on DE gene thresholds\n\n")
  cat(paste0(
    "<ul>",
    paste0("<li>", enrichment_messages, "</li>", collapse = ""),
    "</ul>"
  ))
}
```

## Gene Ontology (GO) Enrichment Analysis

Gene Ontology enrichment was performed using the enrichGO function in clusterProfiler v4.8 (Yu et al. 2012) in each of three GO categories (BP, MF, CC). **Interactive GO enrichment plots** are based on the top 10 significantly enriched GO terms per GO category per gene list. Hover over the plot to view p-value, gene ratio, and up to the top 20 DE genes (sorted by DE adj.p.value) in that term.

To assess similarities between gene lists' enrichment results, if a gene list(s) had significant results for a different gene lists' top-10 term, that result is displayed as well regardless of whether or not the result was in top 10. **Downloadable results excel file** include all significant results for all gene lists.

### DE genes

Gene lists are significantly DE genes per contrast

```{r GO enrichment,eval=TRUE}
# Generate dynamic gene lists
gene_lists <- list()

for (i in seq_along(entrez_ids_list)) {
  contrast_name <- names(entrez_ids_list)[i] %>%
    gsub("top_DE_entrezIDs_?", "", .)

  up_entry <- entrez_ids_list[[i]]$up
  down_entry <- entrez_ids_list[[i]]$down

  # Add upregulated genes
  if (length(up_entry$entrez_ids) > 0) {
    gene_lists[[paste0(contrast_name, ".up")]] <- up_entry$entrez_ids
  }

  # Add downregulated genes
  if (length(down_entry$entrez_ids) > 0) {
    gene_lists[[paste0(contrast_name, ".down")]] <- down_entry$entrez_ids
  }
}
```

```{r run GO}
# Perform GO Enrichment for BP, MF, CC
GO_BP_results <- generate_enrichment_plot(
  gene_lists = gene_lists, 
  de_results_df = bind_rows(efit_results_dfs, .id = "contrast"), 
  universe_entrez = universe_entrez,
  ont_category = "BP",
  annotation_db = report_params$annotation_db
)

GO_MF_results <- generate_enrichment_plot(
  gene_lists = gene_lists, 
  de_results_df = bind_rows(efit_results_dfs, .id = "contrast"), 
  universe_entrez = universe_entrez,
  ont_category = "MF",
  annotation_db = report_params$annotation_db
)

GO_CC_results <- generate_enrichment_plot(
  gene_lists = gene_lists, 
  de_results_df = bind_rows(efit_results_dfs, .id = "contrast"), 
  universe_entrez = universe_entrez,
  ont_category = "CC",
  annotation_db = report_params$annotation_db
)
```

```{r GO enrich plots,fig.width=12, fig.height=10}
# Display interactive plots
download_button_png(GO_BP_results$static_plot, "GO_BP_enrich_plot",height = 12)
GO_BP_results$interactive_plot

download_button_png(GO_MF_results$static_plot, "GO_MF_enrich_plot",height=12)
GO_MF_results$interactive_plot

download_button_png(GO_CC_results$static_plot, "GO_CC_enrich_plot",height=12)
GO_CC_results$interactive_plot

# Combine GO results into a single list of data frames (some might be NULL)
GO_results_list <- list(
  "BP_Results" = GO_BP_results$go_results,
  "MF_Results" = GO_MF_results$go_results,
  "CC_Results" = GO_CC_results$go_results
)

# Remove NULL elements
GO_results_list <- GO_results_list[!sapply(GO_results_list, is.null)]

# Download GO results as an Excel file if any exist
if (length(GO_results_list) > 0) {
  GO_results_list %>% downloadthis::download_this(
    output_name = "GO_results",
    output_extension = ".xlsx",
    button_label = "Download GO enrichment results for all GO categories and all contrasts",
    button_type = "primary",
    has_icon = TRUE,
    icon = "fa fa-save"
  )
} else {
  cat("<b>No GO enrichment results available to download.</b>")
}
```

## KEGG Pathway Enrichment Analysis

KEGG enrichment was performed using the enrichKEGG function in clusterProfiler v4.8 (Yu et al. 2012). **Interactive KEGG enrichment plots** are based on the top 10 significantly enriched KEGG pathways per gene list. Hover over the plot to view p-value, gene ratio, and up to the top 20 DE genes (sorted by DE adj.p.value) in that pathway.

To assess similarities between gene lists' enrichment results, if a gene list(s) had significant results for a different gene lists' top-10 pathway, that result is displayed as well regardless of whether or not the result was in top 10. **Downloadable results excel file** include all significant results for all gene lists.

```{r KEGG,eval=TRUE}
# Run the function
kegg_results <- generate_kegg_enrichment_plot(
  gene_lists = gene_lists, 
  de_results_df = bind_rows(efit_results_dfs, .id = "contrast"), 
  universe_entrez = universe_entrez,
  annotation_db = report_params$annotation_db 
)
```

### DE genes

Gene lists are significantly DE genes per contrast

```{r kegg plot,fig.width=12, fig.height=10}
download_button_png(kegg_results$static_plot, "kegg_enrichment_plot",height=12)
kegg_results$interactive_plot


kegg_results$kegg_results %>%  downloadthis::download_this(
  output_name = "KEGG_results",
  output_extension = ".xlsx",
  button_label = "Download KEGG enrichment results for all contrasts",
button_type = "primary",
  has_icon = TRUE,
  icon = "fa fa-save"
)
```

```{r cleanup_temp_dir, echo=FALSE, message=FALSE}
if (!is.null(params$out_dir) && dir.exists(params$out_dir)) {
  unlink(params$out_dir, recursive = TRUE)
}
```


# References

- Robinson MD, McCarthy DJ and Smyth GK (2010). edgeR: a Bioconductor package for differential expression analysis of digital gene expression data. Bioinformatics
  26, 139-140
- Tarazona S, García-Alcalde F, Dopazo J, Ferrer A, Conesa A (2011). *Differential expression in RNA-seq: a matter of depth*. Genome Research, 21(12), 2213-2223.  
- Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK (2015). “limma powers differential expression analyses for RNA-sequencing and microarray studies.” Nucleic Acids Research, 43(7), e47. doi:10.1093/nar/gkv007.
- Yu G, Wang L, Han Y, He Q (2012). “clusterProfiler: an R package for comparing biological themes among gene clusters.” OMICS: A Journal of Integrative Biology, 16(5), 284-287. doi:10.1089/omi.2011.0118.
- R Core Team (2021). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.
- Kolde R (2019). pheatmap: Pretty Heatmaps. R package version 1.0.12, <https://CRAN.R-project.org/package=pheatmap>.
- Galili, Tal, O'Callaghan, Alan, Sidi, Jonathan, Sievert, Carson (2017). “heatmaply: an R package for creating interactive cluster heatmaps for online publishing.” Bioinformatics. 
- Sievert C (2020). Interactive Web-Based Data Visualization with R, plotly, and shiny. Chapman and Hall/CRC. ISBN 9781138331457, https://plotly-r.com.



